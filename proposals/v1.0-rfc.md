# RFC: IDE Extension Standard v1.0

## Summary

This RFC proposes the stabilization of the IDE Extension Standard at version 1.0.0. The standard defines a common WebAssembly-based interface for IDE extensions, enabling cross-IDE portability while maintaining security through capability-based sandboxing.

## Motivation

### The Extension Ecosystem Problem

Today's IDE extension ecosystems are fragmented:

1. **VS Code** has 50,000+ extensions, but they only work in VS Code
2. **JetBrains** has a separate plugin ecosystem with its own APIs
3. **Zed**, **Lapce**, **Helix**, and other emerging editors each have proprietary extension systems

Extension authors must choose which platform to support, and users are locked into ecosystems based on extension availability.

### Why WebAssembly?

WebAssembly provides the foundation for a universal extension format:

- **Portability**: WASM runs on any platform that implements the host interfaces
- **Security**: Sandboxed execution with explicit capability grants
- **Performance**: Near-native execution speed
- **Language Flexibility**: Extensions can be written in Rust, C/C++, Go, AssemblyScript, etc.

### Why a Standard?

An open standard enables:

1. **Write Once, Run Anywhere**: Extensions target the standard, not specific IDEs
2. **Shared Ecosystem**: Network effects across all conformant IDEs
3. **Clear Contracts**: Well-defined interfaces reduce integration friction
4. **Progressive Adoption**: IDEs can implement subsets via conformance levels

## Detailed Design

### Interface Categories

The standard organizes interfaces into 7 categories:

| Category | Purpose | Example Interfaces |
|----------|---------|-------------------|
| `core` | Fundamental extension infrastructure | lifecycle, logging, context, events, storage |
| `editor` | Text document manipulation | text, selection, decorations |
| `workspace` | File system and project access | filesystem, project |
| `ui` | User interface contributions | notifications, commands, menus, quickpick, webview |
| `language` | Language intelligence features | completion, diagnostics, hover, definition, symbols |
| `network` | External communication | fetch, websocket, realtime |
| `collaboration` | Real-time multi-user editing | crdt, awareness, session |

### Permission Model

Extensions declare required permissions in their manifest:

```json
{
  "permissions": [
    "workspace:read",
    "editor:write",
    "network:fetch:api.github.com"
  ]
}
```

Permissions follow a hierarchical format: `<category>:<scope>[:<qualifier>]`

**Permission Levels:**
- **Low Risk**: Auto-approvable (`ui:notifications`, `core:events`)
- **Medium Risk**: User prompt required (`workspace:read`, `editor:write`)
- **High Risk**: Explicit warning (`network:fetch`, `ui:webview`)
- **Dangerous**: Strong warning (`network:fetch:*`, combined network + file write)

### Conformance Levels

IDEs implement the standard progressively:

| Level | Name | Key Capabilities | Target IDEs |
|-------|------|------------------|-------------|
| 0 | Minimal | Lifecycle, logging | Proof-of-concept |
| 1 | Basic | Commands, notifications, storage, events | Simple editors |
| 2 | Editor | Text editing, decorations | Text editors |
| 3 | Workspace | File system, project structure | Code editors |
| 4 | Language | Completions, diagnostics, navigation | Full IDEs |
| 5 | Full | Network, webviews | Feature-complete |

### Optional Capabilities

Some features are optional, not part of conformance levels:

**Collaboration Capability:**
- CRDT-based document synchronization
- Cursor and presence awareness
- Session management

Extensions declare optional capabilities:
```json
{
  "optionalCapabilities": ["collaboration"]
}
```

This allows extensions to gracefully degrade when capabilities are unavailable.

### WIT Interface Definitions

All interfaces are defined using WebAssembly Interface Types (WIT):

```wit
package ide-extension:core@0.1.0;

interface lifecycle {
    enum deactivation-reason {
        user-disabled,
        shutdown,
        uninstalled,
        error,
    }

    on-activate: func() -> result<_, string>;
    on-deactivate: func(reason: deactivation-reason);
    is-active: func() -> bool;
}
```

### Manifest Format

Extensions use a JSON manifest (`extension.json`):

```json
{
  "name": "my-extension",
  "version": "1.0.0",
  "displayName": "My Extension",
  "description": "A cross-IDE extension",
  "runtime": "wasm32-wasi",
  "main": "extension.wasm",
  "standardVersion": "1.0.0",
  "conformanceLevel": 3,
  "permissions": ["workspace:read", "ui:notifications"],
  "activationEvents": ["workspaceContains:Cargo.toml"],
  "contributes": {
    "commands": [
      {
        "id": "myExtension.helloWorld",
        "title": "Hello World"
      }
    ]
  }
}
```

### Extension Lifecycle

1. **Installation**: IDE validates manifest and WASM module
2. **Permission Grant**: User approves requested permissions
3. **Activation**: IDE calls `activate()` based on activation events
4. **Execution**: Extension uses granted capabilities
5. **Deactivation**: IDE calls `deactivate()` with reason
6. **Uninstallation**: Cleanup and permission revocation

### Handler Interfaces

For push-based events, extensions export handler interfaces:

```wit
interface event-handler {
    on-event: func(event: event-data);
}
```

IDEs can call these handlers instead of requiring extensions to poll.

## Drawbacks

1. **Abstraction Overhead**: Standard interfaces may not expose every IDE's unique capabilities
2. **WASM Limitations**: Some operations (direct filesystem, native UI) require careful design
3. **Learning Curve**: Developers must learn a new extension model
4. **Version Management**: API evolution requires careful compatibility planning
5. **Ecosystem Building**: Initial adoption requires buy-in from multiple IDE projects

## Alternatives

### Option A: VS Code Extension API Compatibility

Attempt to run VS Code extensions via compatibility layer.

**Pros**: Existing ecosystem of 50,000+ extensions
**Cons**:
- JavaScript-based, not WASM-native
- Tight coupling to VS Code assumptions
- Legal concerns with Microsoft's API

### Option B: JSON-RPC Language Server Protocol (LSP) Style

Define all communication as JSON-RPC messages.

**Pros**: Proven model from LSP
**Cons**:
- Higher latency than direct function calls
- Less type safety
- More complex implementation

### Option C: Native Plugin APIs

Each IDE maintains its own plugin system.

**Pros**: Maximum flexibility, optimal performance
**Cons**:
- No portability
- Fragmented ecosystem
- Duplicate effort

### Option D: This Proposal (WASM + WIT Standard)

**Pros**:
- WASM-native with strong sandboxing
- WIT provides type-safe interfaces
- Progressive adoption via conformance levels
- Community-driven governance

**Cons**:
- Requires new tooling and learning
- Smaller initial ecosystem

## Unresolved Questions

### Interface Versioning

How should we handle breaking changes in WIT interfaces?

**Proposal**: Semantic versioning with package versions (e.g., `@0.1.0`, `@1.0.0`)

### Host-Specific Features

How do IDEs expose capabilities beyond the standard?

**Proposal**: Allow `ide-specific:*` namespace for non-portable extensions

### Testing Infrastructure

What testing tools should be standardized?

**Proposal**: Official conformance test suite with mock host implementation

### AI/LLM Integration

Should AI capabilities be part of the standard?

**Proposal**: Define as optional capability in v1.1

## Future Possibilities

### v1.1 Candidates

- **AI Integration**: Standard interfaces for LLM-powered features
- **Remote Development**: Extensions running on remote hosts
- **Debugging Protocol**: DAP-like debugging interface
- **Testing Framework**: Built-in test runner support

### v2.0 Vision

- **Component Model**: Full WASI Preview 2 adoption
- **Composition**: Extensions composed from reusable components
- **Marketplace**: Shared extension marketplace infrastructure

## References

- [WASI](https://wasi.dev/) - WebAssembly System Interface
- [Component Model](https://component-model.bytecodealliance.org/) - WebAssembly Component Model
- [WIT](https://component-model.bytecodealliance.org/design/wit.html) - WebAssembly Interface Types
- [VS Code Extension API](https://code.visualstudio.com/api) - Prior art
- [LSP](https://microsoft.github.io/language-server-protocol/) - Language Server Protocol

---

## Appendix A: Complete Permission Matrix

| Permission | Risk | Description |
|------------|------|-------------|
| `core:events` | Low | Subscribe to IDE events |
| `storage:local` | Medium | Workspace-scoped storage |
| `storage:global` | Medium | Global storage |
| `storage:secrets` | High | Encrypted credential storage |
| `editor:read` | Medium | Read document content |
| `editor:write` | Medium | Modify document content |
| `editor:selection` | Medium | Read/modify selections |
| `editor:decorations` | Low | Add visual decorations |
| `workspace:read` | Medium | Read workspace files |
| `workspace:write` | High | Write workspace files |
| `workspace:config` | Medium | Read configuration |
| `ui:notifications` | Low | Show notifications |
| `ui:commands` | Low | Register commands |
| `ui:menus` | Low | Contribute to menus |
| `ui:quickpick` | Low | Show quick pick dialogs |
| `ui:webview` | High | Create webview panels |
| `language:completion` | Low | Provide completions |
| `language:diagnostics` | Low | Report diagnostics |
| `language:hover` | Low | Provide hover info |
| `language:definition` | Low | Provide navigation |
| `language:symbols` | Low | Provide symbols |
| `network:fetch` | High | HTTP requests (any domain) |
| `network:fetch:<domain>` | High | HTTP to specific domain |
| `network:websocket` | High | WebSocket connections |
| `network:realtime` | Dangerous | Realtime pub/sub |
| `collaboration:session` | High | Session management |
| `collaboration:crdt` | High | CRDT operations |
| `collaboration:awareness` | Medium | Presence sync |

## Appendix B: Migration Guide

### From VS Code Extensions

1. **Manifest**: Convert `package.json` to `extension.json`
2. **Language**: Rewrite in Rust/AssemblyScript targeting WASM
3. **APIs**: Map VS Code APIs to standard interfaces
4. **Activation**: Use standard activation events

### From Native Plugins

1. **Isolation**: Accept sandboxed execution model
2. **Capabilities**: Declare required permissions
3. **Interfaces**: Implement WIT exports

## Appendix C: Governance

### Standard Maintainers

- Core maintainer team (TBD)
- RFC review process
- Monthly sync meetings

### Contribution Process

1. Open RFC for significant changes
2. Two-week comment period
3. Maintainer review and vote
4. Implementation and conformance tests

### Versioning Policy

- Major: Breaking changes to WIT interfaces
- Minor: New interfaces, optional features
- Patch: Bug fixes, documentation
